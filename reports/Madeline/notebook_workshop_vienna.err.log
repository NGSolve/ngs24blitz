Traceback (most recent call last):
  File "/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/jupyter_cache/executors/utils.py", line 58, in single_nb_execution
    executenb(
  File "/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/nbclient/client.py", line 1314, in execute
    return NotebookClient(nb=nb, resources=resources, km=km, **kwargs).execute()
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/jupyter_core/utils/__init__.py", line 165, in wrapped
    return loop.run_until_complete(inner)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/asyncio/base_events.py", line 687, in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
  File "/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/nbclient/client.py", line 709, in async_execute
    await self.async_execute_cell(
  File "/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/nbclient/client.py", line 1062, in async_execute_cell
    await self._check_raise_for_error(cell, cell_index, exec_reply)
  File "/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/nbclient/client.py", line 918, in _check_raise_for_error
    raise CellExecutionError.from_cell_and_msg(cell, exec_reply_content)
nbclient.exceptions.CellExecutionError: An error occurred while executing the following cell:
------------------
import matplotlib.pyplot as plt
from ngsolve import *
import ngsolve
import math
import matplotlib.tri as mtri


def rho(x,λ,r_0):
    if λ >=-1:
        return λ/((f(λ,r_0,1)-f(λ,r_0,r_0))*sqrt(λ*x**2+1))
    elif λ <= -1/r_0**2:
        return  -λ/((f(λ,r_0,1)-f(λ,r_0,r_0))*sqrt(-λ*x**2-1))

def f(λ,r_0,x):
    if λ >=-1:
        return sqrt(1+λ*x**2)- log(sqrt(1+λ*x**2)+1)+log(x)
    if λ <= -1/r_0**2:
        return sqrt(-λ*x**2-1)-atan(sqrt(-λ*x**2-1))

def A_lambda(λ):
    return math.sqrt(abs(λ+1/r_0**2))/ (f(λ,r_0,1)-f(λ,r_0,r_0))


def ϕ(λ,r_0,x):
    return (f(λ,r_0,1)-f(λ,r_0,x))/(f(λ,r_0,1)-f(λ,r_0,r_0))

#Définition de l'espace 
r_0 = 0.5
λ = -10

#espace = Demi_disque((0,-1), 2.0,0.5,(-3,-3),(2,-1))
#espace = Square(0.3,(-1,-1),(1,1))
espace = Anneau(0.5, 1.0)
maillage = Maillage(0.08, espace)

deriv_normal = maillage.get_derive_normal()[1] 
fes = H1(maillage.mesh, order = 1)


ρ_exact = GridFunction(fes)
ρ_exact.Set(rho(sqrt(x**2+y**2),λ,r_0))

phi_exact = GridFunction(fes)
phi_exact.Set(ϕ(λ,r_0,sqrt(x**2+y**2)))

val_A = GridFunction(fes)
val_A.Set(A_lambda(λ))


p_H1 = Problem_2D(maillage,val_A)


print("p_H1",p_H1.is_lower())


ρ_grid = GridFunction(fes)
ρ_grid.Set(x+y +4) 
ρ_array = np.array(ρ_grid.vec)
ρ_init = ρ_array


res_H1 = p_H1.minimize(ρ_array)
print("H1",res_H1.nit, res_H1.success, res_H1.status, res_H1.message)
ρ_sol_grid_H1 = maillage.discret_to_grid(res_H1.x, True)
phi1_H1 = p_H1.solve_phi1(ρ_sol_grid_H1)
phi2_H1 = p_H1.solve_phi2(ρ_sol_grid_H1)


def lower(f : GridFunction, a : int):
    """f<=a"""
    list = []
    flag = True
    for i in range(f.vec.size):
        if f.vec[i] -a>10e-10:
            flag = False
            list.append(f.vec[i])
    print(list)
    return flag

def upper(f : GridFunction, a : int):
    """f >a"""
    flag = True
    list = []
    for i in range(f.vec.size):
        if f.vec[i] <=a:
            flag = False
            list.append(f.vec[i])
    return flag


print('phi1_H1<=1' , lower(phi1_H1,1))



triangles = []

for el in maillage.mesh.Elements(VOL): #prend tous les triangles?
    v = el.vertices
    triangles.append([v[0].nr, v[1].nr, v[2].nr])


fig = plt.figure()
ax = fig.add_subplot(2,2,1,projection ='3d')

X = np.array([v.point[0] for v in maillage.mesh.vertices])
Y = np.array([v.point[1] for v in maillage.mesh.vertices])
#phi_exact = GridFunction(fes)
#phi_exact.Set(ϕ(λ,r_0,sqrt(x**2+y**2)))
#rho_triang = rho(sqrt(X**2+Y**2),λ,r_0)

triang = mtri.Triangulation(X,Y,triangles = triangles)
#ax.plot_trisurf(triang, rho_triang , label = "rho_init", cmap = plt.cm.Spectral)
ax.plot_trisurf(triang, np.array(phi1_H1.vec), label = "phi1", cmap = plt.cm.Spectral)
ax.legend()


ax = fig.add_subplot(2,2,2, projection = '3d')

ax.plot_trisurf(triang, np.array(phi2_H1.vec), label = "phi2", cmap = plt.cm.Spectral)
ax.legend()

ax = fig.add_subplot(2,2,3, projection = '3d')

ax.plot_trisurf(triang, np.array(res_H1.x), label = "rho_num", cmap = plt.cm.Spectral)
ax.legend()



#soustract_phi = GridFunction(fes)
#soustract_phi.Set(phi1-phi2)

fig.suptitle("Solution pour A = 1.5, rho = x+4+y")

plt.show()


soustract_rho_H1 = GridFunction(fes)
soustract_rho_H1.Set(ρ_sol_grid_H1 - ρ_exact)
print("norme L2 rho_num_H1 -rho_exact", maillage.norme_L2_carre(soustract_rho_H1))


soustract_phi1_H1 = GridFunction(fes)
soustract_phi1_H1.Set(phi1_H1- phi_exact)
print("norme L2 phi1_H1 - phi_exact", maillage.norme_L2_carre(soustract_phi1_H1))


soustract_phi2_H1 = GridFunction(fes)
soustract_phi2_H1.Set(phi2_H1- phi_exact)
print("norme L2 phi2_H1 - phi_exact", maillage.norme_L2_carre(soustract_phi2_H1))
#print("norme L2 phi1-phi2", maillage.norme_L2_carre(soustract_phi))

------------------

----- stdout -----
2.400353870955472
p_H1 True
----- stdout -----
H1 24 True 0 CONVERGENCE: REL_REDUCTION_OF_F_<=_FACTR*EPSMCH
[]
phi1_H1<=1 True
------------------

[0;31m---------------------------------------------------------------------------[0m
[0;31mNgException[0m                               Traceback (most recent call last)
Cell [0;32mIn[7], line 139[0m
[1;32m    137[0m soustract_rho_H1 [38;5;241m=[39m GridFunction(fes)
[1;32m    138[0m soustract_rho_H1[38;5;241m.[39mSet(ρ_sol_grid_H1 [38;5;241m-[39m ρ_exact)
[0;32m--> 139[0m [38;5;28mprint[39m([38;5;124m"[39m[38;5;124mnorme L2 rho_num_H1 -rho_exact[39m[38;5;124m"[39m, [43mmaillage[49m[38;5;241;43m.[39;49m[43mnorme_L2_carre[49m[43m([49m[43msoustract_rho_H1[49m[43m)[49m)
[1;32m    142[0m soustract_phi1_H1 [38;5;241m=[39m GridFunction(fes)
[1;32m    143[0m soustract_phi1_H1[38;5;241m.[39mSet(phi1_H1[38;5;241m-[39m phi_exact)

Cell [0;32mIn[5], line 119[0m, in [0;36mMaillage.norme_L2_carre[0;34m(self, u)[0m
[1;32m    107[0m [38;5;28;01mdef[39;00m [38;5;21mnorme_L2_carre[39m([38;5;28mself[39m, u : GridFunction) [38;5;241m-[39m[38;5;241m>[39m [38;5;28mfloat[39m:
[1;32m    108[0m [38;5;250m    [39m[38;5;124;03m"""[39;00m
[1;32m    109[0m [38;5;124;03m    Permet de calculer la norme L2 au carré[39;00m
[1;32m    110[0m 
[0;32m   (...)[0m
[1;32m    117[0m [38;5;124;03m    float : norme L2 carré de u[39;00m
[1;32m    118[0m [38;5;124;03m    """[39;00m
[0;32m--> 119[0m     [38;5;28;01mreturn[39;00m [38;5;28;43mself[39;49m[38;5;241;43m.[39;49m[43minner_L2[49m[43m([49m[43mu[49m[43m,[49m[43mu[49m[43m)[49m

Cell [0;32mIn[5], line 105[0m, in [0;36mMaillage.inner_L2[0;34m(self, u, v)[0m
[1;32m    103[0m u_L2, v_L2 [38;5;241m=[39m fes[38;5;241m.[39mTnT()
[1;32m    104[0m a [38;5;241m=[39m BilinearForm(u_L2[38;5;241m*[39mv_L2[38;5;241m*[39mdx)[38;5;241m.[39mAssemble()
[0;32m--> 105[0m [38;5;28;01mreturn[39;00m [43mInnerProduct[49m[43m([49m[43mu[49m[38;5;241;43m.[39;49m[43mvec[49m[43m,[49m[43m [49m[43ma[49m[38;5;241;43m.[39;49m[43mmat[49m[38;5;241;43m*[39;49m[43mv[49m[38;5;241;43m.[39;49m[43mvec[49m[43m)[49m

[0;31mNgException[0m: BaseVector::InnerProduct: size of me = 448 != size of other = 2328

